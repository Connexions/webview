@import "../../../../styles/variables.less";
@import "../../../../styles/mixins.less";

@DEBUG-NOT-IMPLEMENTED: true;

@blue: @brand-primary;
@page-width: 75%;

// Default character that separates inline list items.
@default-inline-list-item-sep: ';';

// For content with labels we have not converted yet try to show
.x-not-implemented(@msg) when (@DEBUG-NOT-IMPLEMENTED) {
  content: @msg ' NOT_IMPLEMENTED_YET';
  border: 1px dashed black;
  background-color: pink;
}

// Mark unimplemented custom labels
*[data-label]::before {
  .x-not-implemented('data-label');
}


.media-body {
  margin: 0 60px;
  padding: 40px 0;
  counter-reset: figure;

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    margin-bottom: 15px;
    color: @gray-dark;
  }

  p {
    margin: 10px 0 0;
    color: @gray;
  }

  > section,
  > figure,
  > p,
  > .abstract,
  > table {
    &:first-child {
      margin-top: 0 !important; // Ensure first element has no top margin
    }
  }

  > section,
  > figure {
    margin-top: 60px;
  }

  section > section,
  section > figure {
    margin-top: 30px;
  }

  > figure,
  :not(figure) > figure {
    counter-increment: figure;
    counter-reset: subfigure;
  }

  figure {
    width: 100%;
    color: @gray;

    > figcaption {
      padding: 10px;
      font-size: 1.3rem;

      &::before {
        margin-right: 5px;
        color: @gray-medium;
        font-weight: bold;
        content: "Figure " counter(figure) ".";
      }
    }

    > .media {
      display: block;
      margin: 0;
      text-align: center;
    }

    // Subfigures
    > figure {
      counter-increment: subfigure;

      &::after {
        display: block;
        text-align: center;
        content: counter(figure) counter(subfigure, lower-alpha);
      }

      > figcaption::before {
        content: "Figure " counter(figure)counter(subfigure,lower-alpha)".";
      }
    }
  }

  // By default, figures are laid out horizontally
  // unless they have the data-orient="vertical" attribute.
  figure:not([data-orient="vertical"]) {
    display: table;
    table-layout: fixed;
    width: 100%;

    > figcaption {
      display: table-caption;
      caption-side: bottom;
    }

    // Subfigures
    > figure {
      display: table-cell;
    }
  }


  figure[data-orient="vertical"] {
    // The display defaults are correct for figures and subfigures
    // that are displayed vertically.
  }


  // ----------------------
  // Lists
  // ----------------------


  // A list with a title
  .list {
    > .title {
      font-weight: bold;
    }
  }


  // A list contains the following:
  // - list-type-char
  //   - for bulleted lists this is the bullet-char
  //   - for enumerated lists this is the numbering scheme
  //
  // For block lists the numbering and some of the bullets can be handled by the browser;
  // for the rest we need to "simulate".
  //
  // For inline lists we need to "simulate" all of the numbering/bullets

  #list {

    .style(@list-style; @attr-value; @style-type) { }
    .style(bulleted;      @attr-value; @style-type) {
      &[data-bullet-style="@{attr-value}"] { list-style-type: @style-type; }
    }
    .style(enumerated;    @attr-value; @style-type) {
      &[data-number-style="@{attr-value}"] { list-style-type: @style-type; }
    }

    // Only applicable to bulleted lists
    .bulleted-char(block; @attr-value; @char) {
      &[data-bullet-style="@{attr-value}"] {
        list-style-type: none;
        > li::before {
          content: @char;
          margin-right: 0.5em;
        }
      }
    }
    .bulleted-char(block; @attr-value; none) {
      &[data-bullet-style="@{attr-value}"] {
        list-style-type: none;
      }
    }
    .bulleted-char(inline; @attr-value; @char) {
      &[data-bullet-style="@{attr-value}"] {
        > .item::before {
          content: @char;
          margin-right: 0.5em;
        }
      }
    }
    .bulleted-char(inline; @attr-value; none) {
      &[data-bullet-style="@{attr-value}"] {
      }
    }


    // For debugging, show NOT_IMPLEMENTED_YET for anything else
    .bulleted-catchall() {
      &[data-bullet-style]:not([data-bullet-style='bullet']):not([data-bullet-style='open-circle']):not([data-bullet-style='pilcrow']):not([data-bullet-style='rpilcrow']):not([data-bullet-style='section']):not([data-bullet-style='asterisk']):not([data-bullet-style='dash']):not([data-bullet-style='none']) {
        &::before { .x-not-implemented('data-bullet-style=CUSTOM'); }
      }
    }

    // Item separators are so far only supported for inline lists
    .item-sep(block)  {
      // If data-item-sep occurs on a block list then show an error
      &[data-item-sep] { .x-not-implemented('data-item-sep'); }
      // The default item separator for block items is nothing
    }
    .item-sep(inline) {
      &:not([data-item-sep]) > .item:not(:last-child)::after {
        content: @default-inline-list-item-sep;
      }
      &[data-item-sep] > .item:not(:last-child)::after {
        // FIXME: Use the default separator character for now
        content: @default-inline-list-item-sep;
        .x-not-implemented('data-item-sep=CUSTOM');
      }
    }

    .inner(@display; @list-type) {
      // This mixin applies to all display and list-types

      // Enter rules for the separator character (mostly for inline lists)
      .item-sep(@display);

      // if mark-prefix or mark-suffix are used then show this is not implemented yet
      &[data-mark-prefix],
      &[data-mark-suffix] { &::after { .x-not-implemented('data-mark-prefix/suffix'); } }
    }
    .inner(@display; bulleted) {
      // These are always "emulated" for bulleted lists
      .bulleted-char(@display; 'pilcrow';      '\00b6');
      .bulleted-char(@display; 'rpilcrow';     '\204b');
      .bulleted-char(@display; 'section';      '\00a7');
      .bulleted-char(@display; 'asterisk';     '*');
      .bulleted-char(@display; 'dash';         '-');
      .bulleted-char(@display; 'none';         none);

      // For debugging, show NOT_IMPLEMENTED_YET for anything else
      .bulleted-catchall();
    }
    .inner(block; bulleted) {
      // Use the browser to display some of the bullets and "emulate" the rest
      .style(bulleted; 'bullet';       disc);
      .style(bulleted; 'open-circle';  circle);
    }
    .inner(inline; bulleted) {
      // "emulate" all the bullets because inline lists are spans
      .bulleted-char(inline; 'bullet';       '\25cf'); // black circle
      .bulleted-char(inline; 'open-circle';  '\25cb'); // white circle
    }

    .inner(block; enumerated) {
      // Use the browser to display the numbering
      .style(enumerated; 'arabic';      decimal);
      .style(enumerated; 'upper-alpha'; upper-alpha);
      .style(enumerated; 'lower-alpha'; lower-alpha);
      .style(enumerated; 'upper-roman'; upper-roman);
      .style(enumerated; 'lower-roman'; lower-roman);
    }

    .inner(inline; enumerated) {
      // "Emulate" the numbering for inline numbered lists
      .style-emulate(@attr-name; @counter-type) {
        &[data-number-style="@{attr-name}"] > .item::before {
          content: counter(list-item, @counter-type);
          margin-right: 0.5em;
        }
      }
      .style-emulate('arabic';      decimal);
      .style-emulate('upper-alpha'; upper-alpha);
      .style-emulate('lower-alpha'; lower-alpha);
      .style-emulate('upper-roman'; upper-roman);
      .style-emulate('lower-roman'; lower-roman);
    }
  }


  // Block-ish lists
  ul:not([data-display='inline'])         { #list>.inner(block; bulleted); }
  ol:not([data-display='inline'])         { #list>.inner(block; enumerated); }

  // Inline lists (with `data-display='inline'`)
  ul[data-display='inline']               { #list>.inner(inline; bulleted); }
  ol[data-display='inline']               { #list>.inner(inline; enumerated); }

  // Inline lists (in a para)
  p span.list[data-list-type='bulleted']  { #list>.inner(inline; bulleted); }
  p span.list[data-list-type='enumerated']  {
    // Since we have to "emulate" the list, reset and increment the `list-item` counter.
    counter-reset: list-item;
    #list>.inner(inline; enumerated);

    > .item { counter-increment: list-item; }
  }


  .footnote {
    font-size: 1rem;
  }

  .abstract {
    position: relative;
    background-color: @gray-lightest;
    padding: 45px 15px 15px 15px;
    margin: 30px 6rem 0 6rem;

    ul {
      margin: 15px 0 0 0;

      &::after {
        position: absolute;
        top: 15px;
        left: 15px;
        font-size: 1.5rem;
        font-weight: bold;
        color: @gray;
        text-transform: uppercase;
        letter-spacing: 1px;
        content: "Abstract";
      }
    }
  }

  .example,
  .exercise,
  .note {
    margin: 30px 6rem 0 6rem;

    > header {
      border-bottom: 1px solid @gray;

      > .title {
        display: inline-block;
        font-size: 1.5rem;
        text-transform: uppercase;
        letter-spacing: 1px;

        &::before {
          content: ""; // Override content below if desired
          margin-right: 10px;
        }
      }
    }

    > section {
      padding: 5px 15px;
      background-color: @gray-lightest;
    }
  }

  .example,
  .exercise {
    > header {
      border-bottom: 1px solid @gray;

      > .title {
        padding: 0.1em 1em;
        font-weight: bold;
        color: @gray-lightest;
        background-color: @gray;
      }
    }

    .problem,
    .solution {
      padding: 0.5em 1em;
    }

    // Exercise Solutions contain a button to toggle showing or hiding the solution
    .solution {
      border-top: 1px solid @gray;

      // The Show/Hide Solution text
      > .ui-toggle-wrapper {
        text-align: center;

        > .ui-toggle {
          outline: 0;
          text-align: center;
          font-weight: bold;
        }
      }

      &:not(.ui-solution-visible) {
        > .ui-toggle-wrapper > button.ui-toggle::before { content: '[Show Solution]'; }
        > section { display: none; }
      }

      &.ui-solution-visible {
        > .ui-toggle-wrapper > button.ui-toggle::before { content: '[Hide Solution]'; }
      }
    }

    &[data-type=check-understanding] .title::before {
      margin-right: 0;
      content: "";
    }

    &[data-type=conceptual-questions] .problem {
      border-top: none;

      p {
        margin: 0;
      }
    }

    &[data-type=problems-exercises] {
      .problem::before, .solution::before {
        font-weight: bold;
        color: @gray;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .problem::before {
        content: "Problem";
      }

      .solution::before {
        content: "Solution";
      }
    }
  }

  .note {
    padding: 15px;
    background-color: @gray-lightest;

    > header {
      border-bottom: none;

      > .title {
        padding: 0;
        font-weight: normal;
        border-bottom: 1px solid;
        color: @gray;
        background-color: none;
      }
    }
  }

  .example > header > .title::before {
    content: "Example:";
  }

  .exercise > header > .title::before {
    content: "Exercise:";
  }

  .note > header > .title::before {
    content: "Note:";
  }

  //
  // Tables
  // --------------------------------------------------
  table {
    margin-top: 60px;
    width: 100%;
    max-width: 100%;
    margin-bottom: @line-height-computed;
    background-color: @table-bg;

    caption {
      font-size: 1.75rem;

      sup {
        top: auto;
        line-height: inherit;
      }
    }

    // Cells
    thead,
    tbody,
    tfoot {
      > tr {
        > th,
        > td {
          padding: @table-cell-padding;
          line-height: @line-height-base;
          vertical-align: top;
          border-top: 1px solid @table-border-color;
        }
      }
    }

    // Bottom align for column headings
    thead > tr > th,
    thead > tr > td {
      vertical-align: bottom;
      border-bottom: 2px solid @table-border-color;
      font-weight: bold;
      text-align: left;
    }

    // Remove top border from thead by default
    caption + thead,
    colgroup + thead,
    thead:first-child {
      tr:first-child {
        th, td {
          border-top: 0;
        }
      }
    }

    // Account for multiple tbody instances
    tbody + tbody {
      border-top: 2px solid @table-border-color;
    }

    // Nesting
    table {
      background-color: @body-bg;
    }

    // Zebra striping
    > tbody {
      > tr:nth-child(odd) {
        > td,
        > th {
          background-color: @table-bg-accent;
        }
      }
    }
  }
}
